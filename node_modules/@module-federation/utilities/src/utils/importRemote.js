"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.importRemote = void 0;
/**
 * Constant for remote entry file
 * @constant {string}
 */
const REMOTE_ENTRY_FILE = 'remoteEntry.js';
/**
 * Function to load remote
 * @function
 * @param {ImportRemoteOptions['url']} url - The url of the remote module
 * @param {ImportRemoteOptions['scope']} scope - The scope of the remote module
 * @param {ImportRemoteOptions['bustRemoteEntryCache']} bustRemoteEntryCache - Flag to bust the remote entry cache
 * @returns {Promise<void>} A promise that resolves when the remote is loaded
 */
const loadRemote = (url, scope, bustRemoteEntryCache) => new Promise((resolve, reject) => {
    const timestamp = bustRemoteEntryCache ? `?t=${new Date().getTime()}` : '';
    const webpackRequire = __webpack_require__;
    webpackRequire.l(`${url}${timestamp}`, (event) => {
        var _a;
        if ((event === null || event === void 0 ? void 0 : event.type) === 'load') {
            // Script loaded successfully:
            return resolve();
        }
        const realSrc = (_a = event === null || event === void 0 ? void 0 : event.target) === null || _a === void 0 ? void 0 : _a.src;
        const error = new Error();
        error.message = 'Loading script failed.\n(missing: ' + realSrc + ')';
        error.name = 'ScriptExternalLoadError';
        reject(error);
    }, scope);
});
/**
 * Function to initialize sharing
 * @async
 * @function
 */
const initSharing = () => __awaiter(void 0, void 0, void 0, function* () {
    const webpackShareScopes = __webpack_share_scopes__;
    if (!(webpackShareScopes === null || webpackShareScopes === void 0 ? void 0 : webpackShareScopes.default)) {
        yield __webpack_init_sharing__('default');
    }
});
/**
 * Function to initialize container
 * @async
 * @function
 * @param {WebpackRemoteContainer} containerScope - The container scope
 */
const initContainer = (containerScope) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const webpackShareScopes = __webpack_share_scopes__;
        if (!containerScope.__initialized && !containerScope.__initializing) {
            containerScope.__initializing = true;
            yield containerScope.init(webpackShareScopes.default);
            containerScope.__initialized = true;
            delete containerScope.__initializing;
        }
    }
    catch (error) {
        console.error(error);
    }
});
/**
 * Function to import remote
 * @async
 * @function
 * @param {ImportRemoteOptions} options - The options for importing the remote
 * @returns {Promise<T>} A promise that resolves with the imported module
 */
const importRemote = ({ url, scope, module, remoteEntryFileName = REMOTE_ENTRY_FILE, bustRemoteEntryCache = true, }) => __awaiter(void 0, void 0, void 0, function* () {
    const remoteScope = scope;
    if (!window[remoteScope]) {
        let remoteUrl = '';
        if (typeof url === 'string') {
            remoteUrl = url;
        }
        else {
            remoteUrl = yield url();
        }
        // Load the remote and initialize the share scope if it's empty
        yield Promise.all([
            loadRemote(`${remoteUrl}/${remoteEntryFileName}`, scope, bustRemoteEntryCache),
            initSharing(),
        ]);
        if (!window[remoteScope]) {
            throw new Error(`Remote loaded successfully but ${scope} could not be found! Verify that the name is correct in the Webpack configuration!`);
        }
        // Initialize the container to get shared modules and get the module factory:
        const [, moduleFactory] = yield Promise.all([
            initContainer(window[remoteScope]),
            window[remoteScope].get(module === '.' || module.startsWith('./') ? module : `./${module}`),
        ]);
        return moduleFactory();
    }
    else {
        const moduleFactory = yield window[remoteScope].get(module === '.' || module.startsWith('./') ? module : `./${module}`);
        return moduleFactory();
    }
});
exports.importRemote = importRemote;
//# sourceMappingURL=importRemote.js.map